
Wireless_Bootloader_ATmega328.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000006  00800100  00007b08  0000039c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000308  00007800  00007800  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000105  00800106  00800106  000003a2  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  000003a4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000054  00000000  00000000  00000a70  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000020  00000000  00000000  00000ac4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000000bc  00000000  00000000  00000ae4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000002f7  00000000  00000000  00000ba0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000013c  00000000  00000000  00000e97  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000034b  00000000  00000000  00000fd3  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000060  00000000  00000000  00001320  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000001ae  00000000  00000000  00001380  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000020f  00000000  00000000  0000152e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 0000004f  00000000  00000000  0000173d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007800 <__vectors>:
    7800:	0c 94 34 3c 	jmp	0x7868	; 0x7868 <__ctors_end>
    7804:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    7808:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    780c:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    7810:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    7814:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    7818:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    781c:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    7820:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    7824:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    7828:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    782c:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    7830:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    7834:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    7838:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    783c:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    7840:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    7844:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    7848:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    784c:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    7850:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    7854:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    7858:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    785c:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    7860:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>
    7864:	0c 94 51 3c 	jmp	0x78a2	; 0x78a2 <__bad_interrupt>

00007868 <__ctors_end>:
    7868:	11 24       	eor	r1, r1
    786a:	1f be       	out	0x3f, r1	; 63
    786c:	cf ef       	ldi	r28, 0xFF	; 255
    786e:	d8 e0       	ldi	r29, 0x08	; 8
    7870:	de bf       	out	0x3e, r29	; 62
    7872:	cd bf       	out	0x3d, r28	; 61

00007874 <__do_copy_data>:
    7874:	11 e0       	ldi	r17, 0x01	; 1
    7876:	a0 e0       	ldi	r26, 0x00	; 0
    7878:	b1 e0       	ldi	r27, 0x01	; 1
    787a:	e8 e0       	ldi	r30, 0x08	; 8
    787c:	fb e7       	ldi	r31, 0x7B	; 123
    787e:	02 c0       	rjmp	.+4      	; 0x7884 <__do_copy_data+0x10>
    7880:	05 90       	lpm	r0, Z+
    7882:	0d 92       	st	X+, r0
    7884:	a6 30       	cpi	r26, 0x06	; 6
    7886:	b1 07       	cpc	r27, r17
    7888:	d9 f7       	brne	.-10     	; 0x7880 <__do_copy_data+0xc>

0000788a <__do_clear_bss>:
    788a:	12 e0       	ldi	r17, 0x02	; 2
    788c:	a6 e0       	ldi	r26, 0x06	; 6
    788e:	b1 e0       	ldi	r27, 0x01	; 1
    7890:	01 c0       	rjmp	.+2      	; 0x7894 <.do_clear_bss_start>

00007892 <.do_clear_bss_loop>:
    7892:	1d 92       	st	X+, r1

00007894 <.do_clear_bss_start>:
    7894:	ab 30       	cpi	r26, 0x0B	; 11
    7896:	b1 07       	cpc	r27, r17
    7898:	e1 f7       	brne	.-8      	; 0x7892 <.do_clear_bss_loop>
    789a:	0e 94 c0 3c 	call	0x7980	; 0x7980 <main>
    789e:	0c 94 82 3d 	jmp	0x7b04	; 0x7b04 <_exit>

000078a2 <__bad_interrupt>:
    78a2:	0c 94 00 3c 	jmp	0x7800	; 0x7800 <__vectors>

000078a6 <onboard_program_write>:
} page_address;


#define SPM_PAGESIZE 128
void onboard_program_write(uint32_t page, uint8_t *buf)
{
    78a6:	0f 93       	push	r16
    78a8:	1f 93       	push	r17
    78aa:	cf 93       	push	r28
    78ac:	df 93       	push	r29
    78ae:	da 01       	movw	r26, r20
	uint16_t i;
	uint8_t sreg;

	// Disable interrupts.

	sreg = SREG;
    78b0:	1f b7       	in	r17, 0x3f	; 63
	cli();
    78b2:	f8 94       	cli

	eeprom_busy_wait ();
    78b4:	f9 99       	sbic	0x1f, 1	; 31
    78b6:	fe cf       	rjmp	.-4      	; 0x78b4 <onboard_program_write+0xe>

	boot_page_erase (page);
    78b8:	83 e0       	ldi	r24, 0x03	; 3
    78ba:	fb 01       	movw	r30, r22
    78bc:	80 93 57 00 	sts	0x0057, r24
    78c0:	e8 95       	spm
	boot_spm_busy_wait ();
    78c2:	07 b6       	in	r0, 0x37	; 55
    78c4:	00 fc       	sbrc	r0, 0
    78c6:	fd cf       	rjmp	.-6      	; 0x78c2 <onboard_program_write+0x1c>
	uint8_t  byte[2];
} page_address;


#define SPM_PAGESIZE 128
void onboard_program_write(uint32_t page, uint8_t *buf)
    78c8:	cb 01       	movw	r24, r22
    78ca:	80 58       	subi	r24, 0x80	; 128
    78cc:	9f 4f       	sbci	r25, 0xFF	; 255
    78ce:	fb 01       	movw	r30, r22
		// Set up little-endian word.

		uint16_t w = *buf++;
		w += (*buf++) << 8;

		boot_page_fill (page + i, w);
    78d0:	01 e0       	ldi	r16, 0x01	; 1

	for (i=0; i<SPM_PAGESIZE; i+=2)
	{
		// Set up little-endian word.

		uint16_t w = *buf++;
    78d2:	4c 91       	ld	r20, X
		w += (*buf++) << 8;
    78d4:	11 96       	adiw	r26, 0x01	; 1
    78d6:	3c 91       	ld	r19, X
    78d8:	11 97       	sbiw	r26, 0x01	; 1
    78da:	20 e0       	ldi	r18, 0x00	; 0
    78dc:	e9 01       	movw	r28, r18
    78de:	c4 0f       	add	r28, r20
    78e0:	d1 1d       	adc	r29, r1
	uint8_t  byte[2];
} page_address;


#define SPM_PAGESIZE 128
void onboard_program_write(uint32_t page, uint8_t *buf)
    78e2:	12 96       	adiw	r26, 0x02	; 2
		// Set up little-endian word.

		uint16_t w = *buf++;
		w += (*buf++) << 8;

		boot_page_fill (page + i, w);
    78e4:	0e 01       	movw	r0, r28
    78e6:	00 93 57 00 	sts	0x0057, r16
    78ea:	e8 95       	spm
    78ec:	11 24       	eor	r1, r1
    78ee:	32 96       	adiw	r30, 0x02	; 2
	eeprom_busy_wait ();

	boot_page_erase (page);
	boot_spm_busy_wait ();

	for (i=0; i<SPM_PAGESIZE; i+=2)
    78f0:	e8 17       	cp	r30, r24
    78f2:	f9 07       	cpc	r31, r25
    78f4:	71 f7       	brne	.-36     	; 0x78d2 <onboard_program_write+0x2c>
		w += (*buf++) << 8;

		boot_page_fill (page + i, w);
	}

	boot_page_write (page);     // Store buffer in flash page.
    78f6:	85 e0       	ldi	r24, 0x05	; 5
    78f8:	fb 01       	movw	r30, r22
    78fa:	80 93 57 00 	sts	0x0057, r24
    78fe:	e8 95       	spm
	boot_spm_busy_wait ();       // Wait until the memory is written.
    7900:	07 b6       	in	r0, 0x37	; 55
    7902:	00 fc       	sbrc	r0, 0
    7904:	fd cf       	rjmp	.-6      	; 0x7900 <onboard_program_write+0x5a>
	boot_rww_enable ();
    7906:	81 e1       	ldi	r24, 0x11	; 17
    7908:	80 93 57 00 	sts	0x0057, r24
    790c:	e8 95       	spm
	SREG = sreg;
    790e:	1f bf       	out	0x3f, r17	; 63
}
    7910:	df 91       	pop	r29
    7912:	cf 91       	pop	r28
    7914:	1f 91       	pop	r17
    7916:	0f 91       	pop	r16
    7918:	08 95       	ret

0000791a <putch>:
	for(i=0;i< MAX_SIZE_ID;i++)
		putch(NODE_ID[i]);
}
void putch(char ch)
{
	while (!(UCSR0A & _BV(UDRE0)));
    791a:	90 91 c0 00 	lds	r25, 0x00C0
    791e:	95 ff       	sbrs	r25, 5
    7920:	fc cf       	rjmp	.-8      	; 0x791a <putch>
	UDR0 = ch;
    7922:	80 93 c6 00 	sts	0x00C6, r24
}
    7926:	08 95       	ret

00007928 <putchKID>:

void putchKID()
{
	uint8_t i=0;
	for(i=0;i< MAX_SIZE_ID;i++)
		putch(NODE_ID[i]);
    7928:	8e e4       	ldi	r24, 0x4E	; 78
    792a:	0e 94 8d 3c 	call	0x791a	; 0x791a <putch>
    792e:	8f e4       	ldi	r24, 0x4F	; 79
    7930:	0e 94 8d 3c 	call	0x791a	; 0x791a <putch>
    7934:	84 e4       	ldi	r24, 0x44	; 68
    7936:	0e 94 8d 3c 	call	0x791a	; 0x791a <putch>
    793a:	85 e4       	ldi	r24, 0x45	; 69
    793c:	0e 94 8d 3c 	call	0x791a	; 0x791a <putch>
    7940:	80 e3       	ldi	r24, 0x30	; 48
    7942:	0e 94 8d 3c 	call	0x791a	; 0x791a <putch>
}
    7946:	08 95       	ret

00007948 <getch>:
	UDR0 = ch;
}

char getch(void)
{
	retransmit_flag = FALSE;
    7948:	81 e0       	ldi	r24, 0x01	; 1
    794a:	80 93 05 01 	sts	0x0105, r24
	uint32_t count = 0;
    794e:	80 e0       	ldi	r24, 0x00	; 0
    7950:	90 e0       	ldi	r25, 0x00	; 0
    7952:	dc 01       	movw	r26, r24
	while(!(UCSR0A & _BV(RXC0)))
    7954:	0e c0       	rjmp	.+28     	; 0x7972 <getch+0x2a>
	{
		count++;
    7956:	01 96       	adiw	r24, 0x01	; 1
    7958:	a1 1d       	adc	r26, r1
    795a:	b1 1d       	adc	r27, r1
		if (count > MAX_WAIT_IN_CYCLES) //
    795c:	81 3a       	cpi	r24, 0xA1	; 161
    795e:	26 e8       	ldi	r18, 0x86	; 134
    7960:	92 07       	cpc	r25, r18
    7962:	21 e0       	ldi	r18, 0x01	; 1
    7964:	a2 07       	cpc	r26, r18
    7966:	20 e0       	ldi	r18, 0x00	; 0
    7968:	b2 07       	cpc	r27, r18
    796a:	19 f4       	brne	.+6      	; 0x7972 <getch+0x2a>
		{
			retransmit_flag = TRUE;
    796c:	10 92 05 01 	sts	0x0105, r1
			break;
    7970:	04 c0       	rjmp	.+8      	; 0x797a <getch+0x32>

char getch(void)
{
	retransmit_flag = FALSE;
	uint32_t count = 0;
	while(!(UCSR0A & _BV(RXC0)))
    7972:	20 91 c0 00 	lds	r18, 0x00C0
    7976:	27 ff       	sbrs	r18, 7
    7978:	ee cf       	rjmp	.-36     	; 0x7956 <getch+0xe>
			retransmit_flag = TRUE;
			break;
		}
	}

	return UDR0;
    797a:	80 91 c6 00 	lds	r24, 0x00C6
}
    797e:	08 95       	ret

00007980 <main>:


int main(void)
{
    7980:	cf 92       	push	r12
    7982:	df 92       	push	r13
    7984:	ef 92       	push	r14
    7986:	ff 92       	push	r15
    7988:	0f 93       	push	r16
    798a:	1f 93       	push	r17
    798c:	cf 93       	push	r28
    798e:	df 93       	push	r29
	uint8_t check_sum = 0;
	uint16_t i;
	UBRR0H = MYUBRR >> 8;
    7990:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = MYUBRR;
    7994:	83 e3       	ldi	r24, 0x33	; 51
    7996:	80 93 c4 00 	sts	0x00C4, r24
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    799a:	88 e1       	ldi	r24, 0x18	; 24
    799c:	80 93 c1 00 	sts	0x00C1, r24
	putch(5); 
    79a0:	85 e0       	ldi	r24, 0x05	; 5
    79a2:	0e 94 8d 3c 	call	0x791a	; 0x791a <putch>
	uint32_t count = 0;
    79a6:	ee 24       	eor	r14, r14
    79a8:	ff 24       	eor	r15, r15
    79aa:	87 01       	movw	r16, r14
	while(!(UCSR0A & _BV(RXC0)))
    79ac:	13 c0       	rjmp	.+38     	; 0x79d4 <main+0x54>
	{
		count++;
    79ae:	08 94       	sec
    79b0:	e1 1c       	adc	r14, r1
    79b2:	f1 1c       	adc	r15, r1
    79b4:	01 1d       	adc	r16, r1
    79b6:	11 1d       	adc	r17, r1
		if (count > MAX_WAIT_IN_CYCLES)
    79b8:	81 ea       	ldi	r24, 0xA1	; 161
    79ba:	e8 16       	cp	r14, r24
    79bc:	86 e8       	ldi	r24, 0x86	; 134
    79be:	f8 06       	cpc	r15, r24
    79c0:	81 e0       	ldi	r24, 0x01	; 1
    79c2:	08 07       	cpc	r16, r24
    79c4:	80 e0       	ldi	r24, 0x00	; 0
    79c6:	18 07       	cpc	r17, r24
    79c8:	28 f0       	brcs	.+10     	; 0x79d4 <main+0x54>
		{
			app_start();
    79ca:	e0 91 06 01 	lds	r30, 0x0106
    79ce:	f0 91 07 01 	lds	r31, 0x0107
    79d2:	09 95       	icall
	UBRR0H = MYUBRR >> 8;
	UBRR0L = MYUBRR;
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
	putch(5); 
	uint32_t count = 0;
	while(!(UCSR0A & _BV(RXC0)))
    79d4:	80 91 c0 00 	lds	r24, 0x00C0
    79d8:	87 ff       	sbrs	r24, 7
    79da:	e9 cf       	rjmp	.-46     	; 0x79ae <main+0x2e>
		if (count > MAX_WAIT_IN_CYCLES)
		{
			app_start();
		}
	}
	if(UDR0 != 6) app_start();
    79dc:	80 91 c6 00 	lds	r24, 0x00C6
    79e0:	86 30       	cpi	r24, 0x06	; 6
    79e2:	29 f0       	breq	.+10     	; 0x79ee <main+0x6e>
    79e4:	e0 91 06 01 	lds	r30, 0x0106
    79e8:	f0 91 07 01 	lds	r31, 0x0107
    79ec:	09 95       	icall

	putchKID();
    79ee:	0e 94 94 3c 	call	0x7928	; 0x7928 <putchKID>
}


int main(void)
{
	uint8_t check_sum = 0;
    79f2:	80 e0       	ldi	r24, 0x00	; 0
			putchKID();
		}

		if (page_length == 'S')
		{
			boot_rww_enable ();
    79f4:	91 e1       	ldi	r25, 0x11	; 17
    79f6:	d9 2e       	mov	r13, r25
	putchKID();

	while(1)
	{

		if (check_sum != 0)
    79f8:	88 23       	and	r24, r24
    79fa:	11 f0       	breq	.+4      	; 0x7a00 <main+0x80>
			RESTART:
			putch(7);
    79fc:	87 e0       	ldi	r24, 0x07	; 7
    79fe:	01 c0       	rjmp	.+2      	; 0x7a02 <main+0x82>
		else            
			putch('T');
    7a00:	84 e5       	ldi	r24, 0x54	; 84
    7a02:	0e 94 8d 3c 	call	0x791a	; 0x791a <putch>

		while(1)
		{
			if (getch() == ':') break;
    7a06:	0e 94 a4 3c 	call	0x7948	; 0x7948 <getch>
    7a0a:	8a 33       	cpi	r24, 0x3A	; 58
    7a0c:	29 f0       	breq	.+10     	; 0x7a18 <main+0x98>
			if (retransmit_flag == TRUE) goto RESTART;
    7a0e:	80 91 05 01 	lds	r24, 0x0105
    7a12:	88 23       	and	r24, r24
    7a14:	c1 f7       	brne	.-16     	; 0x7a06 <main+0x86>
    7a16:	f2 cf       	rjmp	.-28     	; 0x79fc <main+0x7c>
		}

		page_length = getch();
    7a18:	0e 94 a4 3c 	call	0x7948	; 0x7948 <getch>
    7a1c:	80 93 08 01 	sts	0x0108, r24
		if (retransmit_flag == TRUE) goto RESTART;
    7a20:	90 91 05 01 	lds	r25, 0x0105
    7a24:	99 23       	and	r25, r25
    7a26:	51 f3       	breq	.-44     	; 0x79fc <main+0x7c>

		if(page_length == 'v')
    7a28:	86 37       	cpi	r24, 0x76	; 118
    7a2a:	59 f4       	brne	.+22     	; 0x7a42 <main+0xc2>
		{
			putch('v');
    7a2c:	0e 94 8d 3c 	call	0x791a	; 0x791a <putch>
			putch('0x1');
    7a30:	81 e3       	ldi	r24, 0x31	; 49
    7a32:	0e 94 8d 3c 	call	0x791a	; 0x791a <putch>
			putch('.');
    7a36:	8e e2       	ldi	r24, 0x2E	; 46
    7a38:	0e 94 8d 3c 	call	0x791a	; 0x791a <putch>
			putch('0x0');
    7a3c:	80 e3       	ldi	r24, 0x30	; 48
    7a3e:	0e 94 8d 3c 	call	0x791a	; 0x791a <putch>
		}

		if(page_length == 'k')
    7a42:	80 91 08 01 	lds	r24, 0x0108
    7a46:	8b 36       	cpi	r24, 0x6B	; 107
    7a48:	11 f4       	brne	.+4      	; 0x7a4e <main+0xce>
		{
			putchKID();
    7a4a:	0e 94 94 3c 	call	0x7928	; 0x7928 <putchKID>
		}

		if (page_length == 'S')
    7a4e:	80 91 08 01 	lds	r24, 0x0108
    7a52:	83 35       	cpi	r24, 0x53	; 83
    7a54:	41 f4       	brne	.+16     	; 0x7a66 <main+0xe6>
		{
			boot_rww_enable ();
    7a56:	d0 92 57 00 	sts	0x0057, r13
    7a5a:	e8 95       	spm
			app_start(); 
    7a5c:	e0 91 06 01 	lds	r30, 0x0106
    7a60:	f0 91 07 01 	lds	r31, 0x0107
    7a64:	09 95       	icall
		}

		page_address.byte[0] = getch(); if (retransmit_flag == TRUE) goto RESTART;
    7a66:	0e 94 a4 3c 	call	0x7948	; 0x7948 <getch>
    7a6a:	80 93 09 02 	sts	0x0209, r24
    7a6e:	80 91 05 01 	lds	r24, 0x0105
    7a72:	88 23       	and	r24, r24
    7a74:	09 f4       	brne	.+2      	; 0x7a78 <main+0xf8>
    7a76:	c2 cf       	rjmp	.-124    	; 0x79fc <main+0x7c>
		page_address.byte[1] = getch(); if (retransmit_flag == TRUE) goto RESTART;
    7a78:	0e 94 a4 3c 	call	0x7948	; 0x7948 <getch>
    7a7c:	80 93 0a 02 	sts	0x020A, r24
    7a80:	80 91 05 01 	lds	r24, 0x0105
    7a84:	88 23       	and	r24, r24
    7a86:	09 f4       	brne	.+2      	; 0x7a8a <main+0x10a>
    7a88:	b9 cf       	rjmp	.-142    	; 0x79fc <main+0x7c>

		check_sum = getch();
    7a8a:	0e 94 a4 3c 	call	0x7948	; 0x7948 <getch>
    7a8e:	c8 2e       	mov	r12, r24
		if (retransmit_flag == TRUE) goto RESTART;
    7a90:	80 91 05 01 	lds	r24, 0x0105
    7a94:	88 23       	and	r24, r24
    7a96:	09 f4       	brne	.+2      	; 0x7a9a <main+0x11a>
    7a98:	b1 cf       	rjmp	.-158    	; 0x79fc <main+0x7c>
    7a9a:	c9 e0       	ldi	r28, 0x09	; 9
    7a9c:	d1 e0       	ldi	r29, 0x01	; 1
    7a9e:	7e 01       	movw	r14, r28
    7aa0:	00 e0       	ldi	r16, 0x00	; 0
    7aa2:	10 e0       	ldi	r17, 0x00	; 0
    7aa4:	0c c0       	rjmp	.+24     	; 0x7abe <main+0x13e>

		for(i = 0 ; i < page_length ; i++)
		{
			incoming_page_data[i] = getch();
    7aa6:	0e 94 a4 3c 	call	0x7948	; 0x7948 <getch>
    7aaa:	f7 01       	movw	r30, r14
    7aac:	81 93       	st	Z+, r24
    7aae:	7f 01       	movw	r14, r30
			if (retransmit_flag == TRUE) goto RESTART;
    7ab0:	80 91 05 01 	lds	r24, 0x0105
    7ab4:	88 23       	and	r24, r24
    7ab6:	09 f4       	brne	.+2      	; 0x7aba <main+0x13a>
    7ab8:	a1 cf       	rjmp	.-190    	; 0x79fc <main+0x7c>
		page_address.byte[1] = getch(); if (retransmit_flag == TRUE) goto RESTART;

		check_sum = getch();
		if (retransmit_flag == TRUE) goto RESTART;

		for(i = 0 ; i < page_length ; i++)
    7aba:	0f 5f       	subi	r16, 0xFF	; 255
    7abc:	1f 4f       	sbci	r17, 0xFF	; 255
    7abe:	90 91 08 01 	lds	r25, 0x0108
    7ac2:	29 2f       	mov	r18, r25
    7ac4:	30 e0       	ldi	r19, 0x00	; 0
    7ac6:	02 17       	cp	r16, r18
    7ac8:	13 07       	cpc	r17, r19
    7aca:	68 f3       	brcs	.-38     	; 0x7aa6 <main+0x126>

	return UDR0;
}


int main(void)
    7acc:	27 5f       	subi	r18, 0xF7	; 247
    7ace:	3e 4f       	sbci	r19, 0xFE	; 254
    7ad0:	02 c0       	rjmp	.+4      	; 0x7ad6 <main+0x156>
			incoming_page_data[i] = getch();
			if (retransmit_flag == TRUE) goto RESTART;
		}

		for(i = 0 ; i < page_length ; i++)
			check_sum = check_sum + incoming_page_data[i];
    7ad2:	89 91       	ld	r24, Y+
    7ad4:	c8 0e       	add	r12, r24
		{
			incoming_page_data[i] = getch();
			if (retransmit_flag == TRUE) goto RESTART;
		}

		for(i = 0 ; i < page_length ; i++)
    7ad6:	c2 17       	cp	r28, r18
    7ad8:	d3 07       	cpc	r29, r19
    7ada:	d9 f7       	brne	.-10     	; 0x7ad2 <main+0x152>
			check_sum = check_sum + incoming_page_data[i];

		check_sum = check_sum + page_length;
    7adc:	80 91 0a 02 	lds	r24, 0x020A
    7ae0:	20 91 09 02 	lds	r18, 0x0209
    7ae4:	82 0f       	add	r24, r18
		check_sum = check_sum + page_address.byte[0];
    7ae6:	89 0f       	add	r24, r25
		check_sum = check_sum + page_address.byte[1];
    7ae8:	8c 0d       	add	r24, r12

		if(check_sum == 0) //If we have a good transmission, put it in ink
    7aea:	09 f0       	breq	.+2      	; 0x7aee <main+0x16e>
    7aec:	85 cf       	rjmp	.-246    	; 0x79f8 <main+0x78>
			onboard_program_write((uint32_t)page_address.word, incoming_page_data);
    7aee:	60 91 09 02 	lds	r22, 0x0209
    7af2:	70 91 0a 02 	lds	r23, 0x020A
    7af6:	80 e0       	ldi	r24, 0x00	; 0
    7af8:	90 e0       	ldi	r25, 0x00	; 0
    7afa:	49 e0       	ldi	r20, 0x09	; 9
    7afc:	51 e0       	ldi	r21, 0x01	; 1
    7afe:	0e 94 53 3c 	call	0x78a6	; 0x78a6 <onboard_program_write>
    7b02:	7e cf       	rjmp	.-260    	; 0x7a00 <main+0x80>

00007b04 <_exit>:
    7b04:	f8 94       	cli

00007b06 <__stop_program>:
    7b06:	ff cf       	rjmp	.-2      	; 0x7b06 <__stop_program>
